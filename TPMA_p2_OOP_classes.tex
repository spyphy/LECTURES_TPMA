\input{_head.tex}
\newif\ifFULL
\FULLtrue

\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{graphs}

\begin{document}
\footskip=30pt
\date{}
\title{ТПМА-2: C\# ООП}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{3}  % turn off numeration of sections
\input{_style_csharp.tex}

\fontsize{18pt}{18pt}\selectfont

\tableofcontents 

\newpage

\subsection{Содержание курса}

\bd{Сем.3}: ~ 5 лаб. работ + к.р. + зачет.

\vspace{6mm}

\subsection{Лабораторные}
\begin{enumerate}
 \item Простейшие классы. Инкапсуляция
 \item Массивы. Индексаторы. Исключения 
 \item Перегрузка операций
 \item Наследование
 \item Виртуальные методы
\end{enumerate}




















\newpage

\section{Part 1. Введение в ООП [Lect. 1-2]}

\subsection{Основные парадигмы программирования}$~$

\begin{itemize}
 \item \il{Процедурно-ориентированная (императивная)} парадигма --- программа как последовательность команд.
 
 \item \il{Объектно-ориентированная} парадигма --- программа как совокупность объектов (данные+код), взаимодействующих через интерфейсы.
 
 \item \il{Функциональная} парадигма --- процесс вычисления трактуется как вычисление значений функций в математическом понимании последних: $y=f_1(f_2(f_3(...),f_4(...)))$. Языки LISP, ML.
 
 \item Парадигма \il{логического программирования} --- программа как набор правил логического вывода. Язык PROLOG.

\end{itemize}




\subsection{Принципы ООП}$~$

В реальном мире каждый предмет или процесс обладает набором \emph{статических} и \emph{динамических} характеристик (свойствами и поведением).

\il{Объектно-ориентированное программирование} (ООП) --- это подход к созданию программ, основанный на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса. Объекты взаимодействуют между собой посредством интерфейсов.

Центральная идея ООП --- <<\emph{абстракция}>>.

Смысл абстрагирования в том, чтобы выделить в моделируемом предмете только \textbf{существенные} характеристики и отбросить несущественные. Работа с моделируемой сущностью происходит как с \textbf{единым целым}, не вдаваясь в детали ее внутреннего строения.

Разработка ПО в рамках ООП включает следующие предварительные этапы:

1) ввод в рассмотрение требуемых абстракций;

2) определение допустимых операций над этими абстракциями.

Пример 1: Абстрации --- студент, преподаватель, курс лекций, аудитория. Операции --- назначить студента в группу; прочитать лекцию для группы.

Пример 2: Абстракция --- матрица. Операции --- сложение и умножение матриц.

\subsubsection{Зачем нужно ООП?}$~$

--- позволяет работать с моделируемой системой на языке предметной области;

--- упрощает проектирование сложных систем (ООП решает задачу структурного программирования на новом уровне).


\subsection{Три концепции (постулата) ООП (!)}
\begin{itemize}
 \item \il{Инкапсуляция} --- это механизм, который объединяет данные (свойства) и код (способ поведения), обрабатывающий эти данные, и защищает и то и другое от внешнего вмешательства или неправильного использования. 
 
 Инкапсуляция в ООП реализуется через понятие \emph{класса}. 
 
 Пользователю нет надобности знать, что происходит внутри используемого класса.

 \item \il{Полиморфизм} --- это механизм, с помощью которого можно использовать одно и то же имя (т.е. один \emph{интерфейс}) для решения нескольких схожих, но технически разных задач.
  
 Например, методы с одинаковым именем, но с разным типом аргументов.

 \item \il{Наследование} --- это процесс, посредством которого один объект может приобретать свойства другого объекта. 
 
 Классы образуют иерархию наследования.
 
 Наследование позволяет повторно использовать существующий код.
\end{itemize}




\subsection{Класс как тип данных}$~$

Объединение данных и кода в ООП приводит к понятию \textbf{класса}.

Класс --- это абстракция определенного понятия из рассматриваемой предметной области. 
Объект класса --- это конкретный экземпляр этого класса.

Класс --- это модель или шаблон, который определяет форму объектов. 

Правильно спроектированный класс должен определять одну и только одну логическую сущность.

\vspace{3mm}

(С матем. точки зрения: класс = множество; объект или экземпляр = элемент этого множества.)


\vspace{5mm}

С точки зрения языка программирования:

\bd{Класс} --- это <<\bd{тип данных}>>, определяемый пользователем.

\bd{Объект} или \bd{экземпляр} класса --- это \bd{переменная} этого типа данных. 

Объект --- это конкретная <<структура>>, хранящаяся в памяти компьютера, которая возникает при создании экземпляра класса и включает в себя данные и код:

\vspace{2mm}
	
	\verb|Объект = данные + код|.

\vspace{2mm}


\subsection{UML-диаграммы}$~$

\bd{UML} (англ. Unified Modeling Language, унифицированный язык моделирования) --- язык графического описания для объектного моделирования в области разработки ПО.

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\center{\includegraphics[width=0.8\linewidth]{pict/UML.jpg}}
\caption{Пример UML-диаграммы}
\label{fig:bloch}
\end{figure}


\subsection{Определение класса в C\#}$~$
	
В C\# определение класса начинается с ключевого слова \verb|class|. 

\emph{Тело} класса заключается в фигурные скобки:

\begin{lstlisting}
class имя_класса {
	тело (члены_класса)
}
\end{lstlisting}

Пример:
\begin{lstlisting}
class MyClass {
	private int x;
	public int getX() { return x;}
}
\end{lstlisting}

$$\xymatrix{ & \textbf{Члены (элементы) класса} \ar[ld] \ar[rd]& \\
 \textbf{поля} & & \textbf{методы} 
}$$

\il{Поля} (члены данные) --- это переменные более элементарных типов. Поля используются для хранения данных об объекте.

\il{Методы} (функции-члены) --- функций для работы с этими полями. Методы определяют поведение объектов, и также описывают интерфейсы, посредством которых объекты взаимодействуют с окружающим миром. 

Пример. Комлексные числа.


\vspace{4mm}

$$\xymatrix{ & \textbf{Члены класса} \ar[ld] \ar[d] \ar[rd]& \\
 \textbf{открытые} & \textbf{закрытые} & \textbf{защищенные} 
}$$

\vspace{4mm}


\emph{Открытые} (\verb|public|) --- доступны из любого места в программе;

\emph{Закрытые} (\verb|private|) --- доступены только в пределах данного класса;

\emph{Защищенные} (\verb|protected|) --- доступны в пределах иерархии классов, т.е. для класса и его потомков.

\bd{Основное правило:} члены, используемые только в классе, должны быть закрыты.

Сокрытие элементов класса реализует принцип инкапсуляции.

\vspace{4mm}

\subsection{Создание экземпляра класса}$~$

В C\# экземпляр конкретного класса создается с помощью ключевого слова \verb|new|:
\begin{lstlisting}
имя_класса имя_объекта = new имя_класса()
\end{lstlisting}

Например,
\begin{lstlisting}
MyClass ob = new MyClass();
\end{lstlisting}

\begin{lstlisting}
int x = new int();
\end{lstlisting}

Оператор \verb|new| динамически (т.е. во время выполнения программы) распределяет память для объекта и возвращает \bd{ссылку} на него, которая затем сохраняется в переменной \verb|ob|.

После этого экземпляр класса будет доступен по имени (по ссылке) \verb|ob|.

Классы (class) в C\# являются \bd{ссылочными} типами данных. Это делает их поведение отличным от поведения типов-значений.

\vspace{5mm}



\subsubsection{Доступ к членам класса извне}

Доступ к полям и методам объекта осуществляется посредством оператора \bd{точка}\verb|(.)|:

\vspace{2mm}

\verb|объект.поле;| 

\verb|объект.метод();| 

\vspace{4mm}

Аналогично осуществляется доступ к статическим членам класса:

\verb|класс.статическое_поле;|

\verb|класс.статический_метод();|

\vspace{4mm}

Например, \verb|int x = 5; x.ToString()|.

\vspace{2mm}

<<Более рабочий пример -- ex12>>.

\vspace{5mm}




\subsubsection{Особенности ссылочных типов*}

В С\# типы данных делятся на типы-значения (value-type) и ссылочные типы (reference-type):
\begin{itemize}
 \item \bd{Типы значений} [\verb|struct, enum|] --- переменная этого типа содержит само значение, которое хранится в стеке.
 \item \bd{Ссылочные} [\verb|class|] --- переменная  содержит не сам объект, а лишь ссылку на него. Объекты хранятся в \emph{управляемой куче} (хип) --- динам. памяти, а ссылки на них --- в стеке.  Ссылочная переменная --- это указатель (или имя) на эту область памяти. Данные уничтожаются во время сборки мусора. У одного объекта может быть несколько имен (ссылок на него).
\end{itemize}

\begin{lstlisting}[caption=ex14]
MyClass a = new MyClass();
a.x = 1;
MyClass b = a; // копируется ссылка, но не данные объекта
b.x = 2;
Console.WriteLine("a.x={0}, b.x={1}", a.x, b.x);
\end{lstlisting}

Проверка на равенство \verb|a==b|. Величины ссылочного типа равны, если они ссылаются на одну и ту же область памяти.

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\center{\includegraphics[width=0.5\linewidth]{pict/reference_type.jpg}}
\caption{Объекты ссылочного типа данных} \label{fig:class}
\end{figure}

Параметр \verb|this| --- это ссылка на сам объект, которая доступа из экземплярного метода класса.


\subsection{Статические поля и методы}$~$

Статические поля существуют в единичном виде и принадлежат всему классу. Все экземпляры класса совместно пользуются одну и ту же переменную, если она объявлена статической.

Статические методы могут работать только со статическими полями этого класса.

Для работы к статическим полям и методам \bd{не требуется} создавать экземпляры класса. Доступ к статическим полям и методам осуществляется \bd{по имени класса}. Например, \verb|Math.PI, Math.Sqrt()|.

Статические члены класса описываются с помощью ключевого слова \verb|static|, например

\begin{lstlisting}[caption=ex13]
class MyClass 
{
	public static int st_value;
	public int getValue() { return st_value; }
	public static int st_met() { return st_value; }
}
\end{lstlisting}

Пример -- статический метод \verb|Main()|.

\vspace{3mm}

Сам класс может быть объявлен как \emph{статический} (\verb|static class|). \\
В этом случае:
\begin{itemize}
 \item все поля и методы должны быть статическими;
 \item нельзя создать объекты такого класса.
\end{itemize}

Например, класс \verb|Math| (\verb|public static class Math|).




%-----------------------------
\newpage
\section{Part 2. Классы в C\#}

\subsection{Подробнее о классах и их членах}$~$

--- Спецификаторы, модификаторы и атрибуты класса

--- Модефикаторы доступа к членам класса

--- Классификация членов класса

\subsubsection{Спецификаторы, модификаторы и атрибуты класса}$~$

\begin{lstlisting}[caption=Общая форма определения класса]
[атрибуты][спец-ры] class имя_класса [: базовый_кл] 
{
	//тело класса (данные и методы)
	[специф-ры] тип имя_переменной;
	[специф-ры] возвращ_тип имя_метода(параметры) 
	{ 
		//тело метода 
	}
}
\end{lstlisting}

\bd{Атрибуты} класса --- содержат дополнительные сведения о классе, которые добавляются в метаданные сборки. Например, [NonSerialized].

\bd{Спецификаторы} (модификаторы) класса --- определяют свойства класса, а также доступность класса для других элементов программы:
\begin{itemize}
 \item \verb|public| --- доступ не ограничен;
 \item \verb|internal| --- доступ только из данной программы (сборки) --- \bd{по умолчанию};
  \item  \verb|new|, \verb|private|, \verb|protected| или \verb|protected internal|  --- только для вложенных классов (напр., new перекрывает унаследованный класс);
 \item \verb|abstract| --- абстрактный класс;
 \item \verb|sealed| --- нельзя создать потомков;
 \item \verb|static| --- статический класс.  
\end{itemize}

Спецификаторы \verb|public, internal, protected, private| называются \emph{спецификаторами (модификаторами) доступа} и задают область видимости класса из внешней части программы.



\subsubsection{Спецификторы доступа членов класса}$~$

\begin{itemize}
 \item \bd{public} --- член класса доступен из любого другого кода в программе;
 \item \bd{protected} --- член класса доступен для данного класса и для его потомков; 
 \item \bd{private} (\emph{по умолчанию}) --- член класса доступен только членам данного класса; 
 \item \bd{internal} --- член видим только в пределах текущей сборки (единицы компиляции);
 \item \bd{protected internal} = protected + internal.
\end{itemize}


\subsubsection{Классификация членов класса}

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\center{\includegraphics[width=0.8\linewidth]{pict/class_members.jpg}}
\caption{Состав класса} \label{fig:class}
\end{figure}

К членам класса относятся:
\begin{itemize}
\item поля (экземплярные и статические \verb|static|);
\item константы \verb|const| (всегда <<статичны>>, т.е. связаны с типом);
\item вложенные типы, например вложенные классы;
\item методы (экземплярные и статические);
\item конструкторы (экземплярные и статические);
\item свойства, события, перегруженные операторы и операторы преобразований.
\end{itemize}




\subsection{Члены данные}$~$

\begin{lstlisting}
[атрибуты] [спецификторы] [const] тип имя [= начальное_значение]
\end{lstlisting}

1) \il{Константы} (ключевое слово \verb|const|) являются частью типа, т.е. считаются статическими, а не экземплярными члеными.

Память под константы не выделятся, они внедряются непосредственно в IL-код (\bd{во время компиляции}). Нельзя передать адрес константы и передать ее по ссылке. Константы должны быть инициализированы в месте их объявления.

\begin{lstlisting}
public const int max = 50;
\end{lstlisting}

\vspace{3mm}

2)  \emph{Поля} --- это \emph{переменные}, описанные в классе. Они бывают: 
\begin{itemize}
\item \emph{экземплярные} (по умолчанию) --- память выделяется при создании экземпляра класса;
\item \verb|readonly| --- запись в поле возможна только из конструктора;
\item \verb|static| --- являются частью типа;
\item \verb|volatile| ---  запрещает компилятору оптимизировать обращение к переменной (имеет значение в многопоточных программах).
\end{itemize}

Возможна комбинация модификаторов, например \verb|static readonly|.

Для первоначальной инициализации статических полей обычно используются статические конструкторы.

Спецификторы доступа public, private (по умолч.), protected, internal, protected internal.

\subsection{Методы}$~$

Общая форма:

\begin{lstlisting}
[спецификаторы] возвращ_тип имя(список_параметров) 
{ тело_метода }
\end{lstlisting}

*Помимо спецификторов доступа могут быть спецификаторы virtual, override, abstract, extern, sealed и др.


\newpage

\section{Part 3. Методы. Конструкторы}$~$

\subsection{Part 3-1. Конструкторы}$~$

Зачем нужны конструкторы?

\emph{Конструкторы} --- это специальный вид методов, предназначенных для корректной \emph{инициализации} объектов класса при их создании, т.е. для задания первоначальных значений переменных экземпляра и любых других установочных процедур.

Имя конструктора всегда совпадает с именем класса. 

Нет возвращаемого типа.

Общая форма конструктора:

\begin{lstlisting}
[доступ] имя_класса(список_параметров) { тело_конструктора }
\end{lstlisting}

Например,
\begin{lstlisting}[caption=ex15]
class MyClass 
{
	private int x;
	public MyClass() { x = -10; } // конс. без парам.
}
\end{lstlisting}

Спецификтором доступа обычно является \verb|public|.

Конструктор вызывается автоматически при создании объекта (с помощью ключевого слова \verb|new|), т.е. при выполнении кода

\begin{lstlisting}
MyClass ob = new MyClass();
\end{lstlisting}

\subsubsection{Конструктор по умолчанию}$~$

Если в классе не определить ни одного конструктора, то компилятор автоматически сгенерирует <<конструктор без параметров>>, который называется \emph{конструктором по умолчанию}. Этот конструктор \emph{обнуляет} все поля класса (значениями \verb|0, null, false|). 

Если определить хотя бы один свой конструктор, то конструктор по умолчанию не создается.


\subsubsection{Параметризированные конструкторы}$~$

\begin{lstlisting}
class MyClass 
{
	private int x;
	public MyClass(int x0) { x = x0; } 
}
...
MyClass ob = new MyClass(100);
\end{lstlisting}


<<Реалистичный пример класса>>


\subsection{Об операторе new}$~$

\begin{lstlisting}
MyClass ob;  // объялена ссылка на экземпляр класса
ob = new MyClass(); // создание экземпляра класса
MyClass ref = ob;
\end{lstlisting}

Создание экземпляра класса с помощью оператора \verb|new| включает следующие этапы:

--- выделяется память под объект (в хипе);

--- инициализируются служебные поля;

--- вызывается конструктор экземпляра.


Здесь MyClass() --- имя конструктора. Если есть конструкторы с параметрами, то:
\begin{lstlisting}
ob = new MyClass(initval); // вызывается конструктор с одним параметром
ob = new MyClass(10, 20); // вызывается конструктор с двумя параметрами
ob = new MyClass(); // без параметров
\end{lstlisting}

Когда есть два или более конструкторов, то говоря об \emph{перегрузке конструкторов} (так как их имена совпадают).


\subsection{Ключевое слово this}$~$

Параметр \verb|this| --- это ссылка на сам объект, которая доступа из экземплярного метода класса.

Применяется:

1) Чтобы Возвратить ссылку на экземпляр (объект) класса:

\begin{lstlisting}
public MyClass GetRef() {
	return this;
}
\end{lstlisting}

2) полю класса присвоить значение одноименного параметра:

\begin{lstlisting}
public void SetX(int x) {
	this.x = x;
}
\end{lstlisting}


\subsubsection{Вызов одно конструктора из другого}$~$

\begin{lstlisting}
имя_конструктора (параметры1) : this(параметры2) { тело_конструктора }
\end{lstlisting}

--- исключает ненужное дублирование кода.


\subsubsection{Инициализация без конструкторов*}$~$

\begin{lstlisting}
new имя_класса { имя = выражение, имя = выражение, ...};
\end{lstlisting}

\begin{lstlisting}
MyClass ob = new MyClass { x = 100, s = "Hello"};
\end{lstlisting}



%------------------------------------
\vspace{8mm}

\subsection{Part 3-2. Подробнее о методах класса [Lect.3]}$~$

\subsubsection{Возвращ. значение, параметры, передача по ссылке}$~$

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/method_call.png}}
\caption{Вызов метода} \label{fig:method_call}
\end{figure}

Общая форма определения метода:

\begin{lstlisting}
[спецификаторы] возвращ_тип имя(список_параметров) 
{ тело_метода }
\end{lstlisting}

Возврат значения происходит с помощью оператора \verb|return значение|. Если метод ничего не возвращает, то указывается возвращаемое значение \verb|void|. Можно использовать оператор \verb|return| для преждевременного выхода из метода.

Пример:
\begin{lstlisting}[caption=Ex31]
public static double SumThree(double x, double y, double z) 
{ 
	double sum = x + y + z; // sum - локальная перем.
	return sum; 
}
...
z = SumThree(a,b,c);
\end{lstlisting}

Здесь: \\
\verb|x, y, z| --- параметры метода; \\
\verb|a, b, c| --- аргументы метода; \\
\verb|sum| --- локальная переменная метода (доступна до конца блока).


Переменные, объявленные на уровне типа (класса), называются \emph{полями} класса, а переменные, объявленные в методах класса, называются \emph{локальными переменными} этого метода.

Если локальная переменная метода совпадает с некоторым полем класса, то происходит сокрытие поля класса:

\begin{lstlisting}[caption=Ex32]
class Example {
	public double sum;  // поле класса
	public double Sum(double x, double y) 
	{ 		
		double sum = x + y; // локальная переменная
		return sum; 
	}
}
\end{lstlisting}

\begin{lstlisting}[caption=Ex32]
class Example {
	public double sum;  // поле класса
	public double Sum(double x, double y) 
	{ 		
		sum = x + y; // поле класса
		return sum; 
	}
}
\end{lstlisting}


\subsubsection{Передача по значению и по ссылке. Как работает ref/out}$~$

Параметр-значение: \verb|void method(int x)|;

Параметр-ссылка: \verb|void method(ref int x)|.

Спецификатор \verb|out| отличается от \verb|ref| тем, что не требуется инициализация переменной перед передачей, однако требуется присвоение значения внутри метода.

1) \emph{Передача по значению}: происходит копирование значения аргумента в область памяти параметров.

2) Ключевое слово \verb|ref| используется для передачи аргумента \emph{по ссылке}, а не по значению. В этом случае изменения переменной внутри метода будут влиять на значение переменной аргумента, используемой при вызове метода.

Как это работает: ключевые слова \verb|ref,out| создают <<\emph{псевдоним}>> для имени переменной (таким образом, у ячейки памяти будет два имени).

\begin{itemize}
 \item Не путать понятие передачи по ссылке с понятием ссылочных типов. Эти понятия не совпадают. 
 \item Ключевое слово ref можно использовать для передачи ссылочных типов.
 \item При передаче по ссылке упаковка-преобразование типа значения не производится. 
\end{itemize}

То есть ссылка может передаваться как по значению, так и по ссылке. По умолчанию ссылочные типы (как и типы-значения) передаются в методы по значению. 

%Передача ссылочного типа по ссылке позволяет вызываемому методу изменять объект, на который указывает ссылочный параметр. Место хранения объекта передается методу в качестве значения ссылочного параметра. Если изменить место хранения параметра (с указанием на новый объект), необходимо изменить место хранения, на который ссылается вызывающий объект. В следующем примере экземпляр ссылочного типа передается как параметр ref. 


\begin{table}
\caption{Передача аргументов методу} \label{ref-out}
\begin{center}
\begin{tabular}
{|p{5.0cm}|p{5.0cm}|p{5.0cm}|}
\hline
	& значимый тип 								& ссылочный тип \\
\hline 
передача по значению (по умолчанию) & копирование значения & копирование ссылки \\
\hline 
передача по ссылке (ref, out) & значение по ссылке & ссылка по ссылке \\
\hline 
\end{tabular}
\end{center}
\end{table}



\subsubsection{Возврат объектов и массивов из методов}$~$

\begin{lstlisting}[caption=Ex36]
class A { ... }
 ...
public A GenerateObjectA() {
	A a = new A();
	return a;
}
\end{lstlisting}


\subsubsection{Переменное число аргументов}$~$

Модификатор \verb|params|:

\begin{lstlisting}[caption=Ex37]
public int Sum(params int[] nums) {
	int s = 0;
	foreach (int x in nums) s += x;
	return s;
}
\end{lstlisting}



\subsubsection{Необязательные аргументы}$~$

Значения параметров могут быть установлены по умолчанию:
\begin{lstlisting}[caption=Ex38]
public int Func(int x, int y=1, int z=2) {
	return x+y+z;
}
res = Func(1);
\end{lstlisting}

Необязательные аргументы должны стоять справа от обязательных.

%-----


\subsubsection{Именованные аргументы}$~$

При использовании \emph{именованных аргументов} порядок их следования не имеет значения (и может не совпадаеть с порядком следования параметров метода).

\begin{lstlisting}[caption=Ex39]
public int Vol(int hight, int width, int deep) {
	return hight*width*(deep+1);
}
res = Vol(deep : 1, hight : 5, width : 2);
\end{lstlisting}


\subsubsection{Переменное число аргументов}$~$

Используется ключевое слово \verb|params|:

\begin{lstlisting}
public int Sum(params int[] m) { return m.Length; }
...
Sum(4,6,7,8);
\end{lstlisting}


\subsubsection{Перегрузка методов}$~$

\emph{Перегрузка методов} --- это использование нескольких методов с одним именем, но разными параметрами (т.е. отличающихся типом или количеством параметров):

\begin{lstlisting}[caption=Ex385]
class MyClass 
{
	private int x;
	public void SetX(int a) { x = a;}
	public void SetX(string s) 
		{ x = Convert.ToInt32(s); }
}
\end{lstlisting}

Аналогично происходит \emph{перегрузка конструкторов}.

Статический полиморфизм.


\subsubsection{Рекурсия}$~$

\emph{Рекурсия} --- процесс вызова метода из самого себя:

\begin{lstlisting}[caption=Ex391]
public static int Fract(int x) {
	if (x == 0) return 1;
	return x*Fract(x-1);
}
\end{lstlisting}

(при каждом вызове метода значения параметров помещаются в стек --- возможно переполнение стека).

\emph{Косвенная рекурсия} --- когда два или более методов вызывают друг друга.


\newpage
\subsubsection{Метод Main()}$~$

Метод \verb|Main()| --- точка входа в программу. Он вызывается средой CLR при запуске программы. Рекомендуется создать отдельный класс для запуска программы.

Метод Main() должен быть \verb|static| и должен возвращать значение \verb|int| или \verb|void| (модификатор доступа не влияет):

\begin{lstlisting}
static void Main() {}
static int Main() {... return 0;}
\end{lstlisting}

В метод Main() могут передаваться \emph{аргументы командной строки}:
\begin{lstlisting}[caption=Ex392]
Main(string[] args) 
\end{lstlisting}


%------------




\newpage
\section{Пространство имен. Структура программы (повторение). Отношения между классами}

\subsection{Отступы}$~$

\subsection{Namespace}$~$

\il{Пространство имен} (namespace) --- область объявлений, в которой допускается хранить одно множество имен отдельно от другого. Это помогает избежать \bd{конфликта} имен.

\begin{lstlisting}[caption=Объявление пространства имен]
namespace имя {
	...
}
\end{lstlisting}

Например, пространство имен может содержать объявление какого-нибудь класса

\begin{lstlisting}[caption=Пример]
namespace MySpace {
	class MyClass {}
}
\end{lstlisting}

Доступ к именам пространства возможен двумя способами:

\emph{Способ 1.} Указать имя пространства и имя элемента (класса):

\begin{lstlisting}
MySpace.MyClass obj;
\end{lstlisting}

\emph{Способ 2.} Использовать директиву \verb|using| (в начале файла), которая делает видимыми все члены этого пространства имен:
\begin{lstlisting}
using MySpace;
...
MyClass obj;
\end{lstlisting}

\newpage
\begin{lstlisting}[caption=Шаблон программы на C\# (с классом) - sample-class.cs]
using System;
namespace SolutionName
{
	class MyClass {
		private int x;
	}

	class MyProgram
	{
		static void Main()
		{
			Console.WriteLine("Hello");
			MyClass ob = new MyClass();
		}
	}
}
\end{lstlisting}

Если явно не указывать пространство имен (namespace), то используется \emph{глобальное} пространство имен \verb|global|.

Аддитивный характер пространств имен: пространство имен может быть разделено по нескольким файлам.

Пространства имен могут быть вложены друг в друга (например, \verb|NS1.NS2.ClassA|).

\subsection{Пространство имен System}$~$

Пространство имен \verb|System| содержит часто используемые \bd{классы}, например:
\begin{itemize}
\item \verb|Math| (static) --- содержит математические константы и основные математические функции.
\item \verb|Console| (static) --- класс для ввода-вывода текстовой информации на консоль.
\item .Net-псевдонимы типов данных: \verb|String|, \verb|Byte|, \verb|Int32|, \verb|Char|, \verb|Boolean| и др.
\end{itemize}


\subsection{Псевдонимы классов и пространств имен(*)}$~$

\begin{lstlisting}
using sys = System;
using print = System.Console;
\end{lstlisting}
















%------------

\newpage
\section{Свойства и индексаторы}$~$

\subsection{Свойства}$~$

\emph{Свойствами} в C\# называется разновидность функций-членой класса, предназначенных для управления \bd{доступом к полям} класса (обычно к private-полям).

\begin{lstlisting}
[атрибуты] [специф.] тип имя_свойства {
	[[атрибуты] [специф.] get код_доступа]
	[[атрибуты] [специф.] set код_доступа]
}
\end{lstlisting}

Пример:
\begin{lstlisting}[caption=Ex41]
private int field;
public int Field { 
	get {return field;}
	set {field = value;}
}
\end{lstlisting}

При компиляции программы в байт-код свойство преобразуется в два метода, называемых \emph{аксессорами} --- они служат для чтения (\verb|get|) и записи (\verb|set|) значений в поле класса. Обычно в одно поле.

Ключевое слово \verb|value| --- параметр, содержащий устанавливаемое значение. 

Метод \verb|get| должен содержать \verb|return|.

Один из аксессоров (\verb|get| или \verb|set|) может отсутствовать.

Доступ для get, set не больше, чем для всего свойства.

Работа со свойством не отличается от работы с полем класса (как если бы оно было открытым):

\begin{lstlisting}[caption=Ex41]
ob.Field = 10;  // вызывается set-аксессор
t = ob.Field;   // вызывается get-аксессор
\end{lstlisting}

\emph{Примеры} применения свойств:

\begin{itemize}
  \item Ограничить диапазон допустимых значений для поля
\end{itemize}


\emph{Ограничения свойств}:

\begin{itemize}
 \item нельзя передать по ссылке в метод (как ref, out);
 \item не поддерживают перегрузку;
\end{itemize}



\subsubsection{Автоматически реализуемые свойства(*)}$~$

\begin{lstlisting}[caption=Ex42]
public int Field { get; set; }
\end{lstlisting}


!Можно обеспечить доступ только по чтению либо только по записи:

\begin{lstlisting}
public int Field { get; private set; }
\end{lstlisting}


\subsection{Массивы (напоминание)}$~$


Массивы в C\# --- это ссылочный тип, т.е. они реализованы в виде объектов. Поэтому для работы с ними необходимо:
\begin{itemize}
 \item объявить переменную, которая будет выполнять роль ссылки на данные массива; 
 \item выделить память под массив с помощью \verb|new|.
\end{itemize}
(аналогично созданию экземпляра класса)

\vspace{3mm}

\emph{Замечание}: В C\# нумерация массива из $n$ элементов: $0$, $1$, ..., $n$-1.

\vspace{3mm}

\begin{lstlisting}[caption=Пример ex51]
int[] a;          // здесь int[] - тип данных
a = new int[n];   // n - размер массива
int[] b = a;        // присваивание ссылок
b[1] = 100;			
\end{lstlisting}


\newpage
\subsubsection{Структура памяти}$~$

1) Объявление массива (Declaring an Array) 
\begin{lstlisting}
int[] myArray;    // ссылка объявлена, 
                  // но не проинициализирована
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/array_01.png}}
\end{figure}


\vspace{5mm}

2) Создание массива с помощью оператора \verb|new| (Creation of an Array)
\begin{lstlisting}
int[] myArray = new int[6];
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/array_02.png}}
\end{figure}

Элементы массива автоматически инициализируются нулями (значениями по умолчанию).

\vspace{3mm}

3) Создание массива с явной инициализацией (Array Initialization)

\begin{lstlisting}
int[] myArray = { 1, 2, 3, 4, 5, 6 };
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/array_03.png}}
\end{figure}

Эквивалентные формы:

\begin{lstlisting}
int[] myArray = new int[] { 1, 2, 3, 4, 5, 6 };
int[] myArray = new int[6] { 1, 2, 3, 4, 5, 6 };
\end{lstlisting}

4) Обращение к элементам массива:

\begin{lstlisting}
int[] myArray = new int[6];
myArray[1] = 1;
myArray[5] = 5;
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/array_04.png}}
\end{figure}



\subsubsection{System.Array}$~$

\verb|System.Array| --- общий базовый класс для всех массивов.

\begin{itemize}
 \item \verb|Length| --- (свойство) --- количество элементов массива;
 \item \verb|Rank| --- (свойство) --- количество размерностей;
 \item \verb|CopyTo| --- (метод) --- копирование всех элементов;
 \item \verb|Clear| --- (стат. метод) --- обнуление элементов массива. 
\end{itemize}

Пример:
\begin{lstlisting}
a = new int[] { 1, 2, 3 };
int[] b = new int[a.Length];
a.CopyTo(b, 0);
\end{lstlisting}



\subsubsection{Оператор foreach}$~$

Цикл \verb|foreach| служит для циклического обращения к элементам коллекции (массива):

\begin{lstlisting}
foreach (тип имя_переменной_цикла in коллекция) 
   оператор;
\end{lstlisting}

\begin{lstlisting}
int[] A = new int[] { 1, 2, 3 };
foreach (int a in A) { Console.WriteLine(a);  }
\end{lstlisting}

\begin{lstlisting}
for (int i=0; i<A.Length; i++) 
	{ Console.WriteLine(A[i]);  }
\end{lstlisting}




\subsubsection{Двумерный массив}$~$

\verb|тип[,] имя;|

\begin{lstlisting}
int[,] matrix =
{
    {1, 3, 6, 2}, // row 0 values
    {8, 5, 9, 1}, // row 1 values   
    {4, 7, 3, 0} // row 2 values
};
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.26\linewidth]{pict/array_06.png}}
\end{figure}




\subsubsection{Cтупенчатый массив}$~$

Ступенчатый массив --- это массив ссылок на массивы: 

\verb|тип[][] имя;|

\begin{lstlisting}[caption=Пример]
int[][] myJaggedArray = {
    new int[] {5, 7, 2},
    new int[] {10, 20, 40},
    new int[] {3, 25}
};
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/array_05.png}}
\end{figure}



%---------

\subsubsection{Массивы объектов}$~$

Элементами массива могут быть значимые и ссылочные типы.

\begin{lstlisting}[caption=Массивы объектов]
class A { 
  public int x;
};

public static void Main(string[] args)
{
	A[] m = new A[10]; // массив из 10 ссылок null
	m[0] = new A(); // выдел. память под 1-ый объект
}
\end{lstlisting}





%---------


\subsection{Индексаторы}

\emph{Индексатор} --- это функция-член класса, предназначенная для \emph{индексации} объектов класса. 

Индексаторы называются также \emph{свойствами с параметрами}.

Синтаксис аналогичен синтаксису свойства:

\begin{lstlisting}
[атрибуты] [специф.] тип this [список_параметров] 
{
	get { код_доступа }  // получение данных
	set { код_доступа }  // установка данных
}
\end{lstlisting}

Список параметров --- описание индексов для доступа к элементам.


\subsubsection{Типичное использование индексатора}$~$

\begin{lstlisting}
public тип this [int index] 
{
	get { return x[index]; }  // возврат значения
	set { x[index] = value; }  // установка значения
}
\end{lstlisting}

\begin{lstlisting}[caption=ex-1]
class MyClass {
	private char[] m;
	public MyClass() { m = new char[10]; }
	public char this[int i] {
		get { return m[i]; }
		set { m[i] = value; }
	}
}
...
	MyClass ob = new MyClass();		
	Console.WriteLine("ob[5] = " + ob[5]);				
	ob[5] = 'A';
\end{lstlisting}

(можно сделать нумерацию с 1)


\subsubsection{Перегрузка индексатора}

Индексатор может быть перегружен с любым типом и количеством параметров.

\begin{lstlisting}[caption=ex-2]
class Function {
	public double this[double x] {
		get { return 2*Math.Sin(x); }
	}
}
...
	Function f = new Function();		
	Console.WriteLine("f[0.5] = " + f[0.5]);
\end{lstlisting}


\subsubsection{Примеры применение индексатора}$~$

\begin{lstlisting}[caption=ex-3]
class Point {
	public double x, y;
	public double this[int i] {
		get {
			if (i==1) return x;
			if (i==2) return y;
			return 0;
		}
	}
}
...
Point p = new Point();
double x = p[1];
double y = p[2];
\end{lstlisting}

\vspace{5mm}

Пример. Класс Point4 --- точка в 4-мер. пространстве:\\ $(x^{0},x^{1},x^{2},x^{3})=(ct,x,y,z)$.



\subsubsection{Основное применение индексатора}

--- создание специализированного массива с дополнительными ограничениями, чтобы избежать нежелательного доступа.

\vspace{2mm}

Обработка выхода индексы за пределы массива: 1) с флагом ошибки; 2) с генерацией собственного исключения; 3) с генерацией системного исключения.

%----------------------------

\vspace{10mm}

\subsection{Исключения}

\emph{Исключение} (или \emph{исключительная ситуация}) --- это возникновение во время выполнения программы аварийных событий или ошибочных ситуаций. Исключения возникают тогда, когда программа не смогла сделать то, что от не требовалось. \emph{Обработчики исключений} позволяют рационально обрабатывать такие ситуации.

\vspace{3mm}
В C\# исключения реализованы в виде классов, производных от базового класса \verb|Exception|. Подклассу \verb|SystemException| принадлежат все исключения, геренируемы средой CLR.

\vspace{3mm}
Ключевые слова: \verb|try, catch, throw, finally|.

\begin{itemize}
 \item \verb|try| --- задает \emph{котролируемый блок}, в котором могут возникнуть исключения;
 \item \verb|catch| --- \emph{обрабатотчики исключений}, возникших в блоке \verb|try|;
 \item \verb|finally| --- \emph{блок завершения} --- задает блок кода, который выполняется всегда, независимо  от того, было сгенерированo исключение или нет.
 \item \verb|throw| --- оператор для генерации исключений вручную (в блоке \verb|try|), и также используется для повторной генерации (в блоке \verb|catch|);
\end{itemize}

\vspace{3mm}

Общий синтаксис оператора try:

\begin{lstlisting}
try блок [ блоки catch ] [ блок finally ]
\end{lstlisting}

Пример:

\begin{lstlisting}
try {
	// throw new Exception();
}
catch {
	Console.WriteLine("Catch exception.");
}
finally {
	Console.WriteLine("Finally block.");
}
\end{lstlisting}

Блок \verb|catch| может иметь три формы:

\begin{itemize}
 \item \verb|catch (тип имя) { }|
 \item \verb|catch (тип) { }|
 \item \verb|catch { }|
\end{itemize}

\vspace{4mm}

Процедура обработки исключительных ситуаций:
\begin{enumerate}
 \item в блоке \verb|try| возникает ошибка и генерируется системное исключение; исключение можно сгенерировать вручную с помощью \verb|throw|. 
 \item выполнение блока try прекращается и управление передается обработчикам событий;
 \item выполняется соответствующий обработчик событий, если такой был найден (т.е. не более одного блока \verb|catch|);
 \item выполняется блок \verb|finally| (при его наличии);
 \item если требуемый блок catch не был найден --- исключение не обработано, то оно передается на верхний уровень.
\end{enumerate}



\subsubsection{Создание собственных исключений}$~$

\begin{lstlisting}[caption=ex62-01]
class MyException : Exception {
	private string msg;
	public MyException() { msg = "Some error"; }
	public MyException(string s) { msg = s; }
	public override string ToString() { return "MyException: " + msg;	}
}
...
throw new MyException("Index out of range");
...
catch (MyException ex) { 
	Console.WriteLine(ex);
}
\end{lstlisting}


\subsubsection{Использование класса Exception}$~$

Конструкторы класса Exception:
\begin{lstlisting}
public Exception();
public Exception(string сообщение);
public Exception(string сообщение, Exception innerException);
\end{lstlisting}

Основные члены класса Exception:
\begin{itemize}
 \item \verb|Message| (свойства) ---  возвращает текстовое описание соответствующей ошибки (только чтение); 
\end{itemize}



\begin{lstlisting}[caption=ex62-02]
throw new Exception("Index out of range");
...
catch (Exception ex) {  
	Console.WriteLine(ex.Message);
}
\end{lstlisting}

\subsubsection{Часто встречающиеся исключения}

\begin{itemize}
 \item \verb|DivideByZeroException|  --- деление на нуль;
 \item \verb|IndexOutOfRangeException| --- выход индекса за границы массива;
 \item \verb|NullRefernceException| --- попытка использовать пустую ссылку.
\end{itemize}



\vspace{20mm}


\subsection{Деструкторы}$~$

Память под объект выделяется при вызове оператора \verb|new|.

Освобождается память из-под объекта автоматически после того, как не останется ни одной ссылки, указывающий на этот объект (т.е. на эту область памяти). За это отвечает специальный процесс (программа) среды CLR, который называется \emph{сборщиком мусора}.

Для выполнения некоторых действий при удалении объета используются деструкторы:

\verb|[атрибуты] [extern] ~имя_класса() { тело }|


%-------------
\newpage
\section{Перегрузка операторов}

\subsection{Операции над встроенными типами}$~$

\begin{lstlisting}
int a = 2 + 3;
string s = "Hello" + " " + "World";
\end{lstlisting}

\subsection{формы записи}$~$

$3+2*4$

$=+(3, *(2,4)) = plus(3, mult(2,4))$


\subsection{Общая форма перегрузки операторов}$~$

1) Унитарного оператора:

\begin{lstlisting}
public static возвр_тип operator op(тип операнд) 
{ ...  }
\end{lstlisting}

Могут быть перегружены: 

\verb|+, -, !, ++, --, true, false|;

\vspace{4mm}

2) Бинарного оператора:

\begin{lstlisting}
public static возвр_тип operator op(тип операнд1, тип операнд2) 
{ ... }
\end{lstlisting}

Могут быть перегружены: 

\begin{verbatim}
+, -, *, /, %, &, |, ^, <<, >>;
==, !=, <, >, <=, >=    (требуется совместная перегрузки)
\end{verbatim}

\vspace{2mm}

\textbf{Не могут} быть перегружены: 
\begin{itemize}
 \item \verb|[]|  (вместо этого используется индексатор);
 \item \verb|()|;
 \item операторы присваивания \verb|=|;
 \item сокращенные операции (\verb|+=| и др.) перегружаются автоматически;
 \item \verb|. ? && ?? as is new| и др.;
\end{itemize}

\vspace{2mm}

Ограничения:
\begin{itemize}
 \item нельзя использовать модификаторы \verb|ref| и \verb|out|;
\end{itemize}


\vspace{4mm}

Рекомендации:
\begin{itemize}
 \item Не следует менять значения операндов;
 \item Для правильной перегрузки $++$ (чтобы работала постфиксная и префиксная форма) метод не должен модифицировать исходный объект, а должен возвращать новый объект.
\end{itemize}

\subsection{Операции со встроенными типами}$~$

Например, чтобы работали выражения

\verb|b = a + 10;|

и

\verb|b = 10 + a;|

нужно перегрузить оператор \verb|+| два раза в следующих формах:
\begin{verbatim}
public static Vector operator + (Vector a, int k) { ... }
public static Vector operator + (int k, Vector a) { ... }
\end{verbatim}

\subsection{Перегрузка операторов преобразования}$~$

Оператор преобразования --- оператор, который преобразует объект исходного класса в другой тип.

\begin{verbatim}
int a = 5;
double b = a;
long x = (long) b;
\end{verbatim}

\vspace{3mm}

Две формы оператора преобразования --- явная и неявная:

\verb|implicit| --- неявное приведение типов;

\verb|explicit| --- явное приведение типов;

Перегрузка:

\begin{verbatim}
public static implicit operator int (Vector a) { ... }
public static explicit operator int (Vector a) { ... }
\end{verbatim}

Использование:

\begin{verbatim}
i = a;			// implicit
i = (int) a;	// explicit
\end{verbatim}


\subsection{Общие замечания}$~$

\begin{itemize}
 \item нельзя изменить приоритет операций;
 \item при обращии к оператору \verb|+=| автоматически вызывается перегруженный оператор \verb|+|;
\end{itemize}



%======================


\newpage
\section{Lection-8}

Содержание лекции:
\begin{itemize}
 \item ClassExample
 \item Пример обобщения (Vector3 ---> Vector)
 \item Диаграммы классов в UML
 \item Наследование классов 
\end{itemize}


\subsection{Диаграммы классов*}$~$

Литература:
\begin{itemize}
 \item \url{http://book.uml3.ru/sec_3_2}
 \item \url{https://metanit.com/sharp/patterns/1.2.php}
 \end{itemize}

\vspace{2mm}


\emph{Диаграмма классов} --- диаграмма, демонстрирующая классы системы, их атрибуты, методы и взаимосвязи между ними. Входит в UML.

\emph{UML} (Unified Modeling Language, унифицированный язык моделирования) --- язык графического описания для объектного моделирования.



\vspace{3mm}

\textbf{Классы} представлены в рамках, содержащих три компонента:
\begin{itemize}
 \item имя класса (с заглавной буквы, в верхней части рамки);
 \item поля (атрибуты) класса;
 \item методы класса;
\end{itemize}

(обычный класс --- полужирный шрифт; абстрактный класс --- полужирным курсивом;)

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/uml_01.png}}
\caption{UML-диаграмма класса}
\label{fig:bloch}
\end{figure}

\emph{Видимость} членов класса:
\begin{itemize}
 \item <<\verb|+|>> (\verb|public|) --- \emph{открытые} --- открытый доступ;
 \item <<\verb|-|>> (\verb|private|) --- \emph{закрытые} --- только из операций того же класса;
 \item <<\verb|#|>> (\verb|protected|) --- \emph{защищенные} --- только из операций этого же класса и классов, создаваемых на его основе.
\end{itemize}

Подчеркивание описания атрибута соответствует описателю \verb|static|.

\begin{figure}[h] 
\center{\includegraphics[width=0.32\linewidth]{pict/uml_02.png}}
\caption{Пример класса}
\label{fig:bloch}
\end{figure}

Примеры описания атрибутов:
\begin{itemize}
 \item \verb|name| --- только имя атрибута;
 \item \verb|+name| --- имя и открытая видимость;
 \item \verb|-name : String| --- имя, тип и закрытая видимость;
 \item \verb|-name[1..3] : String| --- (для хранения трех составляющих);
 \item \verb|-name : String="Novikov"| --- указано начальное значение;
 \end{itemize}
 

\vspace{4mm}
 
Синтаксис \textbf{операций}: \\
\verb|видимость ИМЯ (параметры) : тип {свойства}| \\
где \emph{параметры} имеют синтаксис: \\
\verb|направление ПАРАМЕТР : тип = значение|


\vspace{2mm}

Примеры:
\begin{itemize}
 \item \verb|move()| --- только имя операции;
 \item \verb|+move(in from, in to)| --- указаны направления передачи и имена параметров;
 \item \verb|+move(in from:Department, in to:Department)| --- указаны типы параметров;
 \item \verb|+getName():String{isQuery}| --- функция, возвращающая значение атрибута;
  \end{itemize}
 

\vspace{6mm}
 
\textbf{Взаимосвязи} --- отношения между классами:

\begin{figure}[h] 
\center{\includegraphics[width=0.5\linewidth]{pict/uml_03.png}}
\caption{Отношения между классами}
\label{fig:bloch}
\end{figure}

1) \emph{Ассоциация} --- это отношение, при котором объекты одного класса неким образом связаны с объектами другого класса.

\begin{lstlisting}
class Team {  }
class Player
{
    public Team Team { get; set; }
}
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.7\linewidth]{pict/uml_041.png}}
\caption{Пример ассоциации}
\label{fig:bloch}
\end{figure}

\vspace{3mm}

Агрегация и композиция являются частными случаями ассоциации:

\vspace{3mm}

\emph{Композиция} --- определяет отношение \textbf{HAS A} (<<имеет>>):

\begin{lstlisting}
public class ElectricEngine { }
 
public class Car
{
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();
    }
}
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.7\linewidth]{pict/uml_042.png}}
\caption{Пример композиции}
\label{fig:bloch}
\end{figure}

\vspace{3mm}

При композиции главный класс <<Автомобиль>> полностью управляет жизненным циклом объекта класса <<Двигатель>>. При уничтожении объекта класса Car вместе с ним будет уничтожен и объект engine класса ElectricEngine. 

\vspace{3mm}

\emph{Агрегация} ---  также реализует отношение \textbf{HAS A} (<<имеет>>), однако связь здесь более слабая:

\begin{lstlisting}
public abstract class Engine { }
 
public class Car
{
    Engine engine;
    public Car(Engine obj)
    {
        engine = obj;
    }
}
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.7\linewidth]{pict/uml_043.png}}
\caption{Пример агрегации}
\label{fig:bloch}
\end{figure}

Здесь передается \textbf{ссылка} на уже имеющийся объект типа Engine. Поэтому этот объект продолжает существовать даже после уничтожения объекта типа Car.

\vspace{3mm}

2) \emph{Вложенные классы}:

\begin{lstlisting}
public class A {
{
	private class B {
		...
	}
}
\end{lstlisting}

\begin{figure}[h] 
\center{\includegraphics[width=0.7\linewidth]{pict/uml_044.png}}
\caption{Вложенные классы}
\label{fig:bloch}
\end{figure}

\vspace{3mm}

3) \emph{Обобщение} (= \emph{наследование}) --- показывает, что один из двух связанных классов (подтип) является частной формой другого (надтипа), который называется обобщением первого. 

\begin{figure}[h] 
\center{\includegraphics[width=0.25\linewidth]{pict/uml_045.png}}
\caption{Обобщение (наследование)}
\label{fig:bloch}
\end{figure}

\begin{lstlisting}
public class Employee {
  ...
}
public class SalariedEmployee : Employee { 
  ...
}
\end{lstlisting}

(Штатный сотрудник является сотрудником.)

\vspace{3mm}

Обобщение (наследование) определяет отношение \textbf{IS A} (<<является>>): 

\vspace{1mm}

\verb|B is A|

\vspace{2mm}

На языке теории множеств: $B \subseteq A$. \\
(Если $x \in B$, то $x \in A$.)

\vspace{2mm}

На языке C\#:
\begin{lstlisting}
public class A {
  ...
}
public class B : A { 
  ...
}
\end{lstlisting}


\vspace{2mm}

Примеры: 

1) Треугольник является многоугольником.

2) Каждое целое число является вещественным числом. \\
($\mathbb{Z} \subset \mathbb{R}$, т.е. если $x \in \mathbb{Z}$, то $x \in \mathbb{R}$.)




%====================================
\vspace{6mm}

\section{Наследование в C\#. Иерархии классов.}

\emph{Наследование} (inheritance) является одним из принципов ООП и позволяет одному классу (который называется \emph{производным}) унаследовать функционал другого класса (называемого \emph{базовым}). 

\vspace{2mm}

\emph{Базовый} (base) = родительский  = предок = суперкласс = (общее);

\emph{Производный} (derived) = дочерний  = потомок = подкласс = (частное).

\vspace{2mm}

Производный класс --- это специализированный вариант базового класса.

\vspace{2mm}

Классы образуют иерархии, в которых производные классы создаются на базе уже существующих классов:

\begin{figure}[h] 
\center{\includegraphics[width=0.6\linewidth]{pict/uml_05.png}}
\caption{Иерархии классов}
\label{fig:bloch}
\end{figure}


Наследование используется для следующих \textbf{целей}:
\begin{itemize}
 \item для исключения из программы (проекта) повторяющихся фрагментов кода;
 \item для упрощения модификации программы;
 \item для упрощения создания новых программ на основе существующих.
\end{itemize}

\vspace{5mm}

Общий синтаксис:

\begin{lstlisting}
class имя_производного_класса : имя_базового_класса {...}
\end{lstlisting}

\vspace{2mm}

\begin{itemize}
 \item ! Наследуются все элементы (поля и методы) базового класса, кроме конструктора; и могут добавляться новые элементы.
 \item в C\# у класса может быть любое количество потомков и только один родитель;
 \item \textbf{тип доступа} к производному классу должен быть таким же, как и у базового класса, или более строгим;
 \item модификатор \verb|sealed| запрещает создавать потомков от данного класса;
 \item элементы \verb|private| базового класса не доступны потомку непосредственно;
 \item элементы \verb|protected| доступны только потомкам;
 \item ключевые слово \verb|new| позволяет заменить элемент базового класса новым элементом с тем же имением (сокрытие имен);
\end{itemize}


\begin{lstlisting}[caption=Ex83 - Иерархия]
class A {
	public int x;
}
class B : A {
	public double y;
}
class C : B {
}
class D : B {
}
\end{lstlisting}


\newpage
\subsection{Конструкторы при наследовании}$~$

\begin{itemize}
\item Конструкторы не наследуются.

\item ! При создании объекта сначала всегда вызывается конструктор базового класса, затем производного (по цепочке иерархии). Таким образом, каждый конструктор инициализирует свою часть объекта.

\item В конструкторе потомка можно указать, какой именно конструктор базового класса следует вызывать --- с помощью ключевого слова \verb|base|.

\begin{lstlisting}[caption=Вызов конструктора базового класса]
конструктор_производного_класса(список_параметров) : base(список_аргументов) {...}
\end{lstlisting}

Если этого не сделать, то будет вызывается конструктор базового класса без параметров.

Но если в классе объявлен хотя бы один конструктор, то конструктор по умолчанию не генерируется! Это может привести к ошибке комплиляции.
\end{itemize}


\emph{Рекомендации:} Каждый конструктор должен отвечать за инициализацию своей части объекта. Так, конструктор потомка дополняет конструктор предка, что позволяет избежать дублирования кода.

\begin{lstlisting}[caption=Ex85]
class B : A {
	public double y;
	public B(int x, double y) : base(x) {  
		this.y = y;
	}
}
\end{lstlisting}


\subsection{Деструкторы при наследовании}$~$

При наследовании порядок вызова деструкторов определено однозначно: сначала производного класса, затем базового. Т.е. в порядке, обратном по сравнению с конструкторами.




\subsection{Ссылки на базовый класс}$~$

\il{Как правило}, переменная \bd{ссылочного} типа может ссылаться только на объект \bd{своего} типа.

Однако есть одно \il{исключение}: Переменной ссылки \verb|a| на объект базового класса \verb|A| может быть присвоена ссылка \verb|b| на объект производного класса \verb|B|.

\begin{lstlisting}[caption=Ссылка на объект базового класса]
class A { public int x=5; }
class B : A { public int y=10; }
public class Program{
	static void Main()
	{
		B b = new B();
		A a = b;		
		System.Console.WriteLine(a.x);
	}
}
\end{lstlisting}

В обратную сторону присваивание возможно только в явном виде:

\begin{lstlisting}[caption=Ex86: В обратную сторону -- только явно]
		B b = new B();
		A a = b;	
		B b2 = (B) a;
		Console.WriteLine(b2.x);
\end{lstlisting}

Конечно, обращаться к полям объекта производного класса \verb|B| по ссылке \verb|a| базового класса \verb|A| мы можем только к тем, что класс \verb|B| унаследовал от \verb|A|:
\begin{lstlisting}[caption=нельзя]
		B b = new B();
		A a = b;	
		Console.WriteLine(a.y);		// error
\end{lstlisting}

Иначе говоря, доступ к полям класса определяется типом ссылки, а не типом объекта.

\vspace{2mm}

Ссылки на базовый класс используются при создании коллекций объектов разных типов (одной иерархии):
\begin{lstlisting}[caption=Ex86]
A[] mas = new A[3];
mas[0] = new B(-2, 8.9);
foreach (A x in mas) { x.show(); } 
\end{lstlisting}

В данном случае решение о том, метод show() какого класса вызвать, принимается на этапе компиляции и определяется \textbf{типом ссылки, а не типом объекта}. Такой механизм называется \emph{ранним связыванием}.

(в данном примере будет выполняться метод show() базового класса для всех элементов массива)


\vspace{4mm}

\subsection{Виртуальные методы}$~$

Возможно также \emph{позднее связывание}, когда выбор нужного метода осуществляется в процессе выполнения программы. 

Тем самым достигается \textbf{динамический полиморфизм}: <<один интерфейс (имя) --- множество методов>>.

Для реализации \textbf{позднего} связывания используются виртуальные методы.


\vspace{4mm}

\emph{Виртуальный метод} --- это метод класса, который может быть переопределен в производных классах так, что конкретная реализация метода для вызова будет определяться во время выполнения программы.  

В языках Java, Python методы являются виртуальными по умолчанию (для которых это допустимо). В C++ и C\# это нужно указывать явно.

\vspace{4mm}

Особенности позднего связывания:
\begin{itemize}
 \item связывание на этапе выполнения программы;
 \item компилятором формируется \emph{таблица виртуальных методов} (VMT), в которой хранятся адреса виртуальных методов;
 \item связь с VMT устанавливается при создании объекта (компилятор автоматически добавляет в конструктор объекта нужный код для этого).
\end{itemize}



\vspace{3mm}

Реализация позднего связывания в языке C\#:
\begin{itemize}
 \item в базовом классе метод объявляется как \emph{виртуальный} с помощью ключевого слова \verb|virtual|;
 \item в производном классе этот метод \emph{переопределяется} с помощью ключевого слова \verb|override|; 
 \item переопределенный метод должен обладать таким же набором параметров, как и одноименный метод базового класса.
\end{itemize}

\vspace{4mm}

Таким образом, позднее связывание происходит тогда и только тогда, когда в базовом классе метод объявлен с ключевым словом \verb|virtual|, а в производных как \verb|override|. В противном случае связывание будет ранним.

\begin{lstlisting}[caption=Ex91 - Позднее связывание]
class A { 
	public virtual void Print() {  }
}

class B : A { 
	public override void Print() {	}	
}
.......
	A a;
	a = new A();
	a.Print();
	a = new B();
	a.Print();		
\end{lstlisting}



\begin{table}
\caption{Позднее и раннее связывание} \label{ref-out}
\begin{center}
\begin{tabular}
{|p{5.0cm}|p{5.0cm}|p{5.0cm}|}
\hline
	& позднее 								& ранее \\
\hline 
ключевые слова & \verb|virtual| в базовом классе, \verb|override| --- в производном & в остальных случаях \\
\hline 
какой метод вызывается & определяется типом объекта & определяется типом ссылки \\
\hline 
когда решается, какой метод будет вызван & во время выполнения программы (динамически) & при компиляции  \\
\hline 
как вызывается метод & по таблице виртуальных методов VMT & по прямому адресу метода  \\
\hline 
скорость вызова метода & долго & быстро  \\
\hline 
\end{tabular}
\end{center}
\end{table}

\vspace{4mm}

Пример использования виртуальных методов: <<\textbf{полиморфный контейнер}>> --- массив ссылок базового (возможно, абстрактного) класса на объекты производных классов.


\begin{lstlisting}[caption=Ex92 - Полиморфный контейнер]
	A[] m = new A[2] {new A(), new B()};
	foreach (A a in m) {
		a.print();	
	}		
\end{lstlisting}


\vspace{4mm}

\subsection{Не путать перегрузку, переопределение, перекрытие}$~$

\begin{itemize}
 \item \textbf{Перегрузка} (overload) методов --- одинаковое имя, но разные параметры (тип или количество);
\begin{lstlisting}
public void func(int x) {...}
public void func(string x) {...}
\end{lstlisting}

 \item \textbf{Переопределение} (override) --- в случае виртуальных методов --- одинакое имя и одинаковые параметры, но разная реализация (тело) методов, т.е. методы принадлежат разным классам одной иерархии --- для динамического связывания;
 
 \begin{lstlisting}
class A { 
	public virtual void Print() {  }
}
class B : A { 
	public override void Print() {	}	
}
\end{lstlisting}
 
 \item \textbf{Перекрытие} --- при использовании ключевого слова \verb|new| --- также одно имя, одинаковые параметры, разная реализация --- но используется для раннего связывания.
 \begin{lstlisting}
class A { 
	public void Print() {  }  // м.б. virtual
}
class B : A { 
	public new void Print() {	}	
}
\end{lstlisting} 
 
\end{itemize}



\vspace{4mm}

\subsection{Абстрактные классы}$~$

Если базовый класс используется лишь для задания общих особенностей (\emph{интерфейса}) производных классов, а \textbf{создавать объекты} такого класса не имеет смысла, то логично объявить такой класс \emph{абстрактным} (\verb|abstract|).

\vspace{3mm}
Особенности абстрактных классов:
\begin{itemize}
 \item нельзя создать экземпляр абстрактного класса;
 \item абстрактный класс может содержать абстрактные методы (на равне с обычными методами/конструкторами).
\end{itemize}
\vspace{3mm}

\emph{Абстрактный} метод --- это разновидность виртуальных методов, которые не содержат тела. Объявляются с помощью ключевого слова \verb|abstract|. Астрактный метод обязательно должен быть переопределен (override) в производных классах.

(в C++ они называются \emph{чисто виртуальными})

\vspace{3mm}
Сравнение абстрактных и виртуальных методов:
\begin{itemize}
\item \bd{virtual} --- виртуальный метод --- метод, который может переопределяться в производных классах с помощью модификатора \bd{override}.

\item \bd{abstract} --- абстрактный метод --- метод базового класса, в котором отсутствуе тело. Автоматически является виртуальным, но слово \verb|virtual| не пишется. Если класс содержит абстрактный метод, то он сам становиться абстрактным (требуется писать \verb|abstract class|).
\end{itemize}




\vspace{4mm}

\subsection{Виртуальные свойства и индексаторы}$~$

Свойства и индексаторы могут быть виртуальными.

\begin{lstlisting}
	public virtual double Height {
		get { return height; }
		set { height=value; }
	}
\end{lstlisting} 

\vspace{4mm}
\subsection{Класс Object}$~$

Класс Object (\verb|object|) --- общий предок для всех классов в C\#.

\vspace{4mm}

\subsection{Рекомендации к программированию}$~$

1) Как \textbf{виртуальные} должны быть описаны методы, которые выполняют во всех классах иерархии одну и ту же функцию, но, возможно, разными способами.

2) Для представления общих понятий, которые предполагается конкретизировать в производных классах, используют \textbf{абстрактные} классы. Как правило, в абстрактном классе задается набор методов, то есть \emph{интерфейс}, который каждый из потомков будет реализовывать по-своему.

3) Обычные методы (не виртуальные) переопределять в производных классах не рекомендуется. Но технически можно.









\newpage

\section{Ссылки}

\subsection{Литература}
\begin{itemize}
 \item Потапова Л.Е., Алейникова Т.Г. Объектно-ориентированное программирование на языке С\#, 2016.
 \item Павловская, Т.А. C\#. Программирование на языке высокого уровня. Учебник для вузов --- СПб.: Питер, 2007. --- 432 c.
 \item Шилдт Г. \il{C\#: 4.0 полное руководство.} --- М., 2011. --- 1056 с.
\end{itemize}

\vspace{4mm}
\subsection{Видеоуроки}

\subsubsection{Начальный уровень}$~$

\begin{enumerate}
 \item Изучение программирования. Основы: \url{https://www.youtube.com/playlist?list=PLDywto_IU4_60HfZ4-JeqRRyTgcTntDsE}  

 \item Изучение программирования. Суть ООП: \url{https://www.youtube.com/playlist?list=PLDywto_IU4_5UdZeKaoe-JWSl9LoaWmH9} 
 
 \item Изучение программирования. C\#: \url{https://www.youtube.com/playlist?list=PLDywto_IU4_5K5ENTasCNw8UZgUwlUG4g} 

 \item Еще больше видео на youtube: \url{https://www.youtube.com/results?search_query=C\%23+\%D0\%B4\%D0\%BB\%D1\%8F+\%D0\%BD\%D0\%B0\%D1\%87\%D0\%B8\%D0\%BD\%D0\%B0\%D1\%8E\%D1\%89\%D0\%B8\%D1\%85}
 
\end{enumerate}
 

\subsubsection{Профессиональный уровень}$~$

\begin{itemize}
 \item Специалист - Язык программирования C\# 6.0: \url{https://www.youtube.com/watch?v=GPUCEKC41aQ&list=PLwTxWhBM8kgJ5K8RHSQPpiUXrpknKsXj_}
\end{itemize}



\end{document} 

