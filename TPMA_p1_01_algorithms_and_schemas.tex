\input{_head.tex}
\newif\ifFULL
\FULLtrue

\usepackage{tikz}  
\usetikzlibrary{graphs}

\begin{document}
\footskip=30pt
\date{}
\title{C\#}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{0}  % turn off numeration of sections
\input{_style_csharp.tex}

\fontsize{18pt}{18pt}\selectfont


\vspace{6mm}

\section{Lect.3. Алгоритмы, Блок-схемы и ЯП}


%------------------------------------------

\subsection{Алгоритмы и классы сложности}$~$

\il{Алгоритм} --- конечный набор четких инструкций, которые необходимо выполнить для того, чтобы по входным данным получить некоторый результат.

\vspace{2mm}
Пример. Решить квадратное уравнение $a x^2 + b x + c = 0$.
Шаг 1. $D = $

\vspace{3mm}

Требования к алгоритмам:
\begin{itemize}
 \item дискретность (последовательное выполнение простых шагов, каждый шаг за конечный отрезок времени);
 \item детерминированность --- каждый следующий шаг работы однозначно определяется состоянием системы.
 \item понятность исполнителю (входят в его систему команд);
 \item завершаемость (\textbf{конечность}) --- алгоритм должен завершать работу и выдавать результат за определенное конечное число шагов.
\end{itemize}


\vspace{3mm}

\il{Машина Тьюринга} --- абстрактная машина (автомат), работающая с лентой отдельных ячеек, в которых записаны символы.

\begin{figure}[h]
\center{\includegraphics[width=0.55\linewidth]{pict1/DMT.jpg}}
\caption{Машина Тьюринга}
\label{fig:hdd}
\end{figure}

{\bf Тезис Тьюринга}: Некоторый алгоритм для нахождения значений функции существует тогда и только тогда, когда функция исчисляется по Тьюрингу, то есть когда ее можно вычислить на машине Тьюринга.

\vspace{2mm}

Здесь постулируется, что любая задача, для которой существует алгоритм решения, может быть решена с помощью Машины Тьюринга, и обратно.

\vspace{2mm}

Однако не все алгоритмы работают одинаково эффективно.

\emph{Сложность алгоритма} --- количественная характеристика ресурсов, необходимых алгоритму для успешного решения задачи.

Основные ресурсы:
\begin{itemize}
 \item время (временная сложность);
 \item объем памяти (емкостная сложность);
\end{itemize}

\vspace{2mm}

Чаще рассматривается временная сложность. 

Порядок роста временной сложности алгоритма с увеличением размера входных данных $n$:
$$T = O(f(n)),$$
где $f$ --- некоторый полином.

\emph{Сложность задачи} оценивается как сложность самого эффективного алгоритма, решающего эту задачу.

\emph{Класс сложности} $C(f(n))$ --- это множество всех задач, для которых существует хотя бы один алгоритм, сложность которого не превышает $O(f(n))$.







\subsection{Виды алгоритмов}$~$

\vspace{3mm}

Различают следующие (базовые) виды алгоритмов:
\begin{itemize}
 \item линейный (последовательное выполнение действий);
 \item разветвленный (содержит условие);
 \item циклический (содержит цикл --- повторение одних и тех же действий).
\end{itemize}

\vspace{3mm}

Формы представления алгоритмов:
\begin{itemize}
 \item графическая --- в виде блок-схем;
 \item словесная --- запись на естественном языке;
 \item псевдокод --- полуформальное описание на условном алгоритмическом языке.
 \item программная --- тексты на языках программирования (Pascal, C\#, Python и др.).
\end{itemize}



\vspace{3mm}

%------------------------------------------
\newpage

\subsection{Блок-схемы}

\il{Блок-схема} --- наглядное графическое изображение алгоритма. Отдельным этапам алгоритма соответствуют блоки (фигуры).

Алгоритм может включать следующие виды блоков:
\begin{itemize}
 \item блок начала-конца алгоритма;
 \item блок ввода-вывода данных; 
 \item блок действия;
 \item условный блок;   
\end{itemize}



%------------------------------------------

\subsection{Алгоритмы}





%------------------------------------------

\subsection{Пример блок-схемы алгоритма}

\begin{figure}[h]
\center{\includegraphics[width=0.55\linewidth]{pict1/block-schema.jpg}}
\caption{Пример блок-схемы}
\label{fig:hdd}
\end{figure}












%------------------------------------------
\newpage

\subsection{Языки программирования}

$$\xymatrix{ & \textbf{ЯП} \ar[ld] \ar[rd]& \\
 \textbf{низкого ур.} &  & \textbf{высокого ур.} 
}$$

\vspace{3mm}

К языкам низкого уровня относится машинный код и язык ассемблера.

\vspace{3mm}

К языкам высокого уровня относятся машинно-независимые языки.



%------------------------------------------


\begin{figure}[h]
\center{\includegraphics[width=1.0\linewidth]{pict1/lang.png}}
\caption{Классификация языков программирования}
\label{fig:hdd}
\end{figure}




{ \small

\begin{table}[h]
\caption{Сравнение функциональности ЯП}
\begin{center}
\begin{tabular}
{|p{3cm}|p{3.5cm}|p{4cm}|p{4cm}|p{3.5cm}|}
\hline
Название 				& {\bf С\#}			& {\bf Python}	& {\bf Pascal}  	& {\bf PascalABC}    	
\\
\hline
Год создания 			& 2002   			& 1991						& 1970 & 2002 \\
\hline
Класс языка 			& ООП (+)    		& мульти-парадигмальный	& императивный, структурированный &  мульти-парадигмальный \\
\hline
Тип исполнения 		& компилируемый   & интепретируемый			& компилируемый & компилируемый \\
\hline
Типизация  	 			& строгая статическая (и динам.) & строгая динамическая & строгая статическая  & строгая статическая \\
\hline
\end{tabular}
\end{center}
\end{table}
}



\emph{Статическая типизация} --- когда переменная связывается с типом в момент объявления (на этапе компиляции) и тип не может быть изменен позже. Языки C++, C\#, JAVA.
\begin{lstlisting}
int x;
x = 10;
\end{lstlisting}

\emph{Динамическая типизация} --- когда переменная связывается с типом в момент присваивания значения (во время выполнения программы), а не в момент объявления переменной. Например, Python, Ruby, JavaScript.
\begin{lstlisting}
x = 10
x = 'abc'
\end{lstlisting}

Система типов называется \emph{строгой} (или <<сильной>>), если она не позволяет выполнять автоматические неявные преобразования типов. Разрешены только явные преобразования. Это исключает возможность возникновения ошибки согласования типов времени выполнения. Этот термин напрямую связан с \emph{типобезопасностью}. Например, в С++ система типов является слабой: характерной чертой является неявное приведение типов и каламбур типизации.


\emph{Явно-типизированные} языки отличаются тем, что тип новых переменных / функций / их аргументов нужно задавать явно. Соответственно языки с неявной типизацией перекладывают эту задачу на компилятор / интерпретатор.


Python: динамическая сильная неявная типизация.

C\#: статическая сильная (явная и неявная) типизация.


\newpage

\subsection{Примеры программ на Pascal, C\#, Python}$~$

\begin{lstlisting}[caption=Pascal]
program SimpleProgram;
var
    n: integer;
begin
    for n := 0 to 10 do
        if n mod 2 = 0 then
            writeln('n = ', n);
end.
\end{lstlisting}


\begin{lstlisting}[caption=PascalABC(?)]
program SimpleProgram;
begin
    for var n := 0 to 10 do
        if n mod 2 = 0 then
            writeln('n = ', n);
end.
\end{lstlisting}



\begin{lstlisting}[caption=C\#]
using System;
namespace ProgSpace
{
	class MyProgram
	{
		static void Main()
		{
			for(int n=0; n<11; n++) {
				if (n % 2 == 0) {
					Console.WriteLine("n = " + n);
				}
			}
		}
	}
}
\end{lstlisting}


\begin{lstlisting}[caption=Python]
for n in range(0, 11):
	if n % 2 == 0:
		print('n = {}'.format(n))
\end{lstlisting}






\newpage

{ \small

\begin{table}[h]
\caption{Сравнение синтаксиса ЯП}
\begin{center}
\begin{tabular}
{|p{3.5cm}|p{3.5cm}|p{3.3cm}|p{4cm}|p{3cm}|}
\hline
Название 				& {\bf С\#}			& {\bf Python}	& {\bf Pascal (PascalABC) }    	& {\bf Псевдокод}
\\
\hline
Условие  	 			&  \verb|if .. else| 	& \verb|if .. else|	& \verb|if .. then .. else| 	& ЕСЛИ .. ТО ... ИНАЧЕ \\	
\hline
Множественное ветвление	&  \verb|switch .. case| & ---		& \verb|case .. of| 	& ВЫБОР  \\	
\hline
Цикл с предусловием  &  \verb|while|	& \verb|while|	& \verb|while| 		 	& ЦИКЛ ПОКА \\	
\hline
Цикл с постусловием &  \verb|do ... while|	& ---		& \verb|repeat ... until| & пока  не\\	
\hline
Итерационный цикл		&  \verb|for, foreach|	& \verb|for .. in ..|	& \verb|for .. to .. do ..| & ЦИКЛ ДЛЯ ...\\	
\hline
Конец инструкции		&  \verb|;|				& (\verb|;| при записи в одну строку) 	& \verb|;|	 & \\	
\hline
Блок инструкций		&  \verb|{ ... }	|	& \emph{отступ} 	& \verb|begin ... end| & начало ... конец\\	
\hline
Присваивание			&  \verb|b = a|	& \verb|b = a|	& \verb|b := a| & $b := a$\\	
\hline
Сравнение &  \verb|a == b| & \verb|a == b| & \verb|a = b| & $a = b$ \\	
\hline
объявление переменных &  \verb|int a;|	& \emph{нет необходимости} & \verb|a: Integer;| (~\verb|var a := 0|~) & \emph{нет необходимости} \\	
\hline
Ввод &  \verb|ReadLine()| & \verb|input()| & \verb|readln()| & \emph{Ввод} \\	
\hline
Вывод &  \verb|WriteLine()| & \verb|print()| & \verb|writeln()| & \emph{Вывод} \\	
\hline
Арифм. операции &  \verb'+ - * /' & \verb|+ - * / **| & \verb|+ - * /| & $+~ -~ \times~ /~ x^y$ \\	
\hline
Целочисл. дел. &  \verb'/ %' & \verb|// %| & \verb|div, mod| & целая часть и остатот от дел. \\	
\hline
Логические операции &  \verb'&&, ||, !' & \verb|and, or, not| & \verb|and, or, not| & И, ИЛИ, НЕ \\	
\hline
Массивы &  \verb'int[] A = {1, 2};' & \verb|A = [1, 2]| & \verb|A: array [1..2]| \verb|of integer;| & A = [1, 2] \\	
\hline
\end{tabular}
\end{center}
\end{table}

}

%----------------



\end{document} 

