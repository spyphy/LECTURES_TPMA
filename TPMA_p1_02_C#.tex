\input{_head.tex}
\newif\ifFULL
\FULLtrue

\usepackage{tikz}  
\usetikzlibrary{graphs}

\begin{document}
\footskip=30pt
\date{}
\title{C\#}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{0}  % turn off numeration of sections
\input{_style_csharp.tex}

\fontsize{18pt}{18pt}\selectfont

Литература
\begin{itemize}
 \item Потапова, Л.Е. Алгоритмизация и  программирование на языке С\# : метод. рекомендации к выполнению лаб. работ / Л.Е. Потапова, Т.Г. Алейникова. --- Витебск : ВГУ, 2014. --- 50 с.
 \item Павловская, Т.А. C\#. Программирование на языке высокого уровня. Учебник для вузов --- СПб.: Питер, 2007. --- 432 c.
 \item Шилдт Г. \il{C\#: 4.0 полное руководство.} --- М., 2011. --- 1056 с.
\end{itemize}


\vspace{6mm}

\section{Lect.3. Введение в ООП (в первом приближении). Пространство имен. Типы данных в C\#}

C\# --- объектно-ориентированный язык.

\subsection{Что такое ООП?}$~$

\il{Объектно-ориентированное программирование} (ООП) --- это подход к созданию программ, основанный на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса. 

Класс = множество. Экземпляр = элемент этого множества. 

Например.

С точки зрения программирования:

\bd{Класс} --- это <<\bd{тип данных}>>.

\bd{Объект} --- это \bd{экземпляр} класса (т.е. переменная этого типа данных). Объект --- это <<структура>> в памяти компьютера, которая возникает при создании экземпляра класса и включает в себя данные и код.

\vspace{2mm}
	
	\verb|Объект = данные + код|.

\vspace{2mm}

	
В C\# определение класса начинается с ключевого слова \verb|class|. Тело класса заключается в фигурные скобки:
\begin{lstlisting}
class MyClass {
	члены_класса
}
\end{lstlisting}

$$\xymatrix{ & \textbf{Члены класса} \ar[ld] \ar[rd]& \\
 \textbf{поля} & & \textbf{методы} 
}$$

\il{Поля} --- это переменные более элементарных типов. Поля используются для хранения данных об объекте.

\il{Методы} --- функций для работы с этими полями. Методы определяют поведение объектов, и также описывают интерфейсы, посредством которых объекты взаимодействуют с окружающим миром. 

В других языках программирования методы могут называться по разному: \il{функции, процедуры, подпрограммы}.

Три концепции ООП:
\begin{itemize}
 \item \il{Инкапсуляция} --- это механизм, который объединяет данные (свойства) и коды (способы поведения), обрабатывающие эти данные, и защищает и то и другое от внешнего вмешательства или неправильного использования.

 \item \il{Полиморфизм} --- это механизм, с помощью которого можно использовать одно и то же имя  для решения нескольких схожих, но технически разных задач. Например, функции с одинаковым именем, но с разным типом аргументов.

 \item \il{Наследование} --- это процесс, посредством которого один объект может приобретать свойства другого объекта. Классы образуют иерархию наследования.
\end{itemize}

Пример. Числа.

\vspace{2mm}

В C\# экземпляр конкретного класса создается с помощью ключевого слова \verb|new|:
\begin{lstlisting}
имя_класса имя_объекта = new имя_класса()
\end{lstlisting}

Например, \verb|int x = new int();|.

Доступ к полям и методам объекта (или класса) осуществляется посредством оператора \bd{точка}\verb|(.)|:

\vspace{2mm}

\verb|объект.поле| 

\verb|объект.метод()| 

\verb|класс.статическое_поле|

\verb|класс.статический_метод()|

\vspace{2mm}

Например, \verb|int x = 5; x.ToString()|.

Для работы к статическим (\verb|static|) полям и методам \bd{не нужно} создавать экземпляры класса. Например, \verb|Math.PI, Math.Sqrt()|.


\vspace{10mm}

%======================

\section{Intro in C\#. Базовые понятия}

\subsection{Некоторые особенности языка C\#}$~$

\subsubsection{Основные отличия C\# от С++}$~$

\begin{itemize}
 \item нельзя объявлять глобальные переменные на уровне проекта и выше (только в классе);
 \item нельзя объявлять локальные  статич. переменные на уровне метода (только на уровне класса);
\end{itemize}


\subsubsection{Основные отличия от Pascal}$~$
\begin{itemize}
 \item Все переменные являются объектами. 
 \item Регистр имеет значение (т.е. \verb|count| и \verb|Count| --- разные имена). 
 \item Вместо \verb|begin ... end| используются скобки \verb|{ ... }|. 
\end{itemize}

\subsection{Минимальная программа на C\#}$~$

\begin{lstlisting}[caption=Минимальная программа на C\#]
class MyProgram
{
	static void Main()
	{
		System.Console.WriteLine("Hello world!");
	}
}
\end{lstlisting}

Класс <<MyProgram>> описывает класс программ. Этот класс содержит единственный метод \verb|Main()|, который является точкой входа --- местом, с которого начинается выполняться наша программа.


\subsection{Инструкции. Блоки. Комментарии}$~$

\il{Инструкция (оператор)} --- это законеченное описание некоторого действия, данных или элемента программы. Инструкции в C\#, как правило, заканчиваются точкой с запятой: 
\begin{lstlisting}
int x = 5;
x = 2*x + 3; 
\end{lstlisting}

\il{Блок} --- это набор инструкций, выделяемый фигурными скобками \verb|{ ... }|. Аналог паскалевского \verb|begin ... end;|


\il{Комментарии} --- поясняющие записи к программе, которые игнорируются компилятором.
\begin{lstlisting}
int x; // однострочный комментарий
/* многострочный 
   комментарий */
\end{lstlisting}




\subsection{Пространства имен}$~$

\il{Пространство имен} (namespace) --- область объявлений, в которой допускается хранить одно множество имен отдельно от другого.

\begin{lstlisting}[caption=Объявление пространства имен]
namespace имя {
	...
}
\end{lstlisting}

Например, пространство имен может содержать объявление какого-нибудь класса

\begin{lstlisting}[caption=Пример]
namespace MySpace {
	class MyClass {}
}
\end{lstlisting}

Тогда для использования этого класса мы должны указать пространство имен, где этот класс объявлен:
\begin{lstlisting}
MySpace.MyClass obj;
\end{lstlisting}
либо использовать директиву \verb|using| (в самом начале файла), которая делает видимыми все члены этого пространства имен:
\begin{lstlisting}
using MySpace;
...
MyClass obj;
\end{lstlisting}


\begin{lstlisting}[caption=Шаблон программы на C\#]
using System;
namespace ProgSpace
{
	class MyProgram
	{
		static void Main()
		{
			Console.WriteLine("Hello");
		}
	}
}
\end{lstlisting}

\subsection{Пространство имен System}$~$

Пространство имен \verb|System| содержит часто используемые \bd{классы}, например следующие классы:
\begin{itemize}
\item \verb|Math| (static) --- содержит математические константы и основные математические функции.
\item \verb|Console| (static) --- класс для ввода-вывода текстовой информации на консоль.
\item \verb|String| --- представляет собой строковый тип. Экземплярами этого класса являются символьные строки (\verb|"некоторый_текст"|).
\end{itemize}

\vspace{3mm}

Пространство имен \verb|System| содержит также многие \bd{структурные типы} (<<значимые типы>>), включая 
\begin{itemize}
 \item числовые (например, \verb|Byte, Int32, Double|);
 \item символьные (\verb|Char|);
 \item логические (\verb|Boolean|) и др.
\end{itemize}


\il{Структура} (\verb|struct|) --- это аналог класса (\verb|class|). Основное отличие в способе хранения данных в памяти компьютера.
$$\xymatrix{ & \textbf{Типы в C\#} \ar[ld] \ar[rd] & \\
 \textbf{типы значений (struct)} & & \textbf{ссылочные (class)} 
}$$

%----------------

\newpage

\section{Основы синтаксиса языка C\#}

\subsection{Основные определения}

Алфавит языка C\# включает
\begin{itemize}
\item буквы (латинские и национальных алфавитов) и символ подчеркивания (\verb|_|), который употребляется наряду с буквами;
\item цифры;
\item специальные символы, например \verb|+, *, { , &|;
\item пробельные символы (пробел и символы табуляции);
\item символы перевода строки
\end{itemize}

\vspace{3mm}

\il{Лексема} --- это минимальная единица языка, имеющая самостоятельный смысл. К лексемам относятся:
\begin{itemize}
\item имена (идентификаторы);
\item ключевые слова;
\item знаки операций;
\item разделители;
\item литералы (константы).
\end{itemize}

\il{Идентификаторы (или обозначения)} --- это имена, которые даются переменным, типам, функциям и меткам в программе.

\il{Ключевые слова} --- это зарезервированные идентификаторы, которые имеют специальное значение для компилятора. Например, \verb|if, for, class|.

\vspace{3mm}

Ограничения на \bd{имена} в C\#:
\begin{itemize}
\item имя должно начинаться с буквы или \verb|_|;
\item имя должно содержать только буквы, знак подчеркивания и цифры;
\item прописные и строчные буквы различаются;
\item имена не должны совпадать с ключевыми словами.
\end{itemize}
Примеры имен: \verb|Vasia, _a13, _A13|.

Некоторые рекоментации по нотации:
\begin{itemize}
\item названия классов и методов пишутся с большой буквы;
\item названия переменных и экземпляторов классов --- с маленькой;
\end{itemize}
Исключения составляют псевдонимы встроенных структурных типов, например, \verb|int, bool| и т.д.

Можно определить свои псевдонимы для встроенных типов:
\begin{lstlisting}
using Int = System.Int32;
using Integer = System.Int32;
	...
	Integer x = 5;
\end{lstlisting}



%----------------

\newpage

\section{Типы данных}

C\# является строго типизированным языком.

Информация, определяемая типом, включает:
\begin{itemize}
\item Внутреннее представление;
\item Диапазон возможных значений;
\item Объем занимаемой памяти;
\item Разрешенные операции;
\item Содержащиеся в типе члены класса;
\item Базовый тип;
\item Область выделяемой памяти при выполнении.
\end{itemize}

\vspace{3mm}

Особенности типов данных в C\#:
\begin{itemize}
\item Переменные любого типа (даже bool и int) являются объектами.
\item Невозможно определить глобальные переменные (или методы) вне классов.
\item Разрядность типов данных не зависит от ОС и процессора.
\item Структуры являются значимыми типами данных, а классы --- ссылочными.
\end{itemize}

\vspace{3mm}

Встроенные типы данных в C\#:
\begin{itemize}
\item логический: \verb|bool| (\verb|System.Boolean|) --- два допустимых значения: \verb|true| и \verb|false|.
\item целочисленные типы: \verb|byte|, \verb|short|, \verb|int|, \verb|long| и др. \\
(соотв. типы .Net: \verb| Byte, Int16, Int32, Int64|)
\item вещественные числовые типы: \verb|float, double, decimal|.
\item символьный тип: \verb|char| (2 байта). Например, \verb|'A'|.
\item строковый тип: \verb|string|.  Например, \verb|"hello"|.
\item object: \verb|object| (\verb|System.Object|).
\end{itemize}
\vspace{3mm}

Замеч.: \verb|int| является псевдонимом типа \verb|System.Int32| (платформы .Net) и т.п.

\subsection{Литералы (константы)}

\il{Литерал} --- постоянное значение, у которого нет имени. Используются для  обозначения числовых значений, строк, символов или логических констант. Они указываются при компиляции и не могут быть изменены во время выполнения. 

Например, \verb|10, -0.53, "строка"|.

По умолчанию
\begin{itemize}
 \item целочисленные литералы имеют наименьший тип, начиная с \verb|int| (т.е. могут быть int, long).
 \item вещественные литералы имеют тип \verb|double|.
\end{itemize}

Для явно задания типа литерала используются суффиксы \\
\verb|L - long, F - float, D - double, M - decimal.|

Суффикс \verb|U| дает беззнаковый тип: \verb|U - uint, UL - ulong|. 

Примеры: \verb|10L, 5U, 15UL, -0.53F, 1.0d, 4.3m|.

\vspace{3mm}

Управляющие символы ...

\vspace{3mm}

\il{Именованные константы} определяются с помощью ключевого слова \verb|const|:

\begin{lstlisting}
const int maxValue = 5;
\end{lstlisting}

Константы должны инициализировать сразу после объявления и не могут измениться в ходе программы. 



\subsection{Переменные и их объявление}$~$

\il{Переменная} --- это величина, которая во время работы программы может изменять свое значение. 

Все переменные, используемые в программе, должны быть описаны.

Для каждой переменной задается ее \bd{имя} и \bd{тип}.


\begin{lstlisting}[caption=Объявление и инициализация переменных]
тип имя_переменной;  // объявление переменной
имя_переменной = значение; // инициализация
тип имя_переменной = значение; // объявление с инициализацией
\end{lstlisting}

Например,
\begin{lstlisting}
int x = 5;
\end{lstlisting}
или, эквивалентно:
\begin{lstlisting}
System.Int32 x = 5;
\end{lstlisting}

Можно объявлять несколько переменных через запятую, и инициализировать их при необходимости:
\begin{lstlisting}
int x, y;
int a = 10, b = -4;
\end{lstlisting}

\il{Область действия переменной} --- это область программы, где можно использовать переменную.

Область действия переменной начинается в точке ее описания и длится до конца блока, внутри которого она описана. Блок --- участок кода, заключенный в фигурные скобки \verb|{...}|.

\il{Время жизни переменных}: переменные создаются при входе в их область действия (блок) и уничтожаются при выходе.




%--------------------------
\newpage



\subsection{Управляющие операторы}$~$

\subsubsection{1. Операторы выбора (или условные операторы)}

\begin{itemize}
\item \verb|if - else|;
\item \verb|switch - case|;
\item Тернарный оператор: \verb|condition ? expr1 : expr2;|
\end{itemize}

a) \verb|if| --- оператор условного ветвления

\begin{lstlisting}
if (условие)
  операторы
else
  операторы
\end{lstlisting}


б) \verb|switch-case| --- оператор выбора, обеспечивает многонаправленное ветвление программы.

\begin{lstlisting}
switch (выражение) {
	case константа1:
		последовательность операторов
		break;
	case константа2:
		последовательность операторов
		break;
	...
	default:
		последовательность операторов
		break;
}
\end{lstlisting}

в) Тернарный оператор: \verb|x = condition ? expr1 : expr2;|


Замечание про \verb|switch|. В C\# (в отличие от C++) запрещены <<провалы>>, т.е. переход от одной ветви \verb|case| в следующую ветвь \verb|case|, кроме случая, когда первая ветвь не содержит операторов. \\
Т.е. допустимо
\begin{lstlisting}[caption=Можно]
    switch (a) {
      case 1:
      case 2: x = 2; break;
    }
\end{lstlisting}

но запрещено

\begin{lstlisting}[caption=Нельзя]
    switch (a) {
      case 1: x = 1; 	// ошибка, нужен break;
      case 2: x = 2; break;
    }
\end{lstlisting}

Поэтому каждая ветвь \verb|case| должна заканчиваться оператором \verb|break| (либо \verb|return| или \verb|goto|).

\vspace{2mm}

\subsubsection{2. Итеративные операторы (циклы)}
Кроме стандартных циклов \verb|for|, \verb|while| и \verb|do-while| в C\# есть  цикл \verb|foreach| для обхода элементов некоторой \il{коллекции}.

a) \verb|for| --- предоставляет механизм итерации, в котором определенное условие проверяется перед выполнением каждой итерации. 

\begin{lstlisting}
for (инициализатор; условие; итератор)
	оператор (операторы)
\end{lstlisting}

инициализатор --- это выражение, вычисляемое перед первым выполнением тела цикла (обычно инициализация локальной переменной в качестве счетчика цикла). Инициализация, как правило, представлена оператором присваивания, задающим первоначальное значение переменной, которая выполняет роль счетчика и управляет циклом;

условие --- это выражение, проверяемое перед каждой новой итерацией цикла (должно возвращать true, чтобы была выполнена следующая итерация);

итератор --- выражение, вычисляемое после каждой итерации (обычно приращение значения счетчика цикла).

Т.обр., выполнение цикла for будет продолжаться до тех пор, пока проверка условия дает истинный результат.


б) \verb|while| --- цикл выполняется до тех пор, пока условие истинно.

\begin{lstlisting}
while (условие)
	операторы;
\end{lstlisting}

Является циклом с предварительной проверкой. 

в) \verb|do...while| --- это версия while с постпроверкой условия, т.е. условие цикла проверяется после выполнения тела цикла. 

\begin{lstlisting}
do {
	операторы;
} while (условие);
\end{lstlisting}

При наличии лишь одного оператора фигурные скобки в данной форме записи необязательны.


Инструкции перехода:
\begin{itemize}
\item \verb|break|  --- выход из всего цикла (и продолжение программы после цикла);
\item \verb|continue| --- преждевременное завершение текущего шага итерации цикла;
\item \verb|return|   --- возврат из метода (можно возвращать значения);
\item \verb|goto|	  --- безусловный переход к данной метке (метка задается как \verb|имя_метки:| ).
\end{itemize}




\end{document} 

